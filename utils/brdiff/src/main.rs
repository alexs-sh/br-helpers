mod show_info;

use base::{diffs, githistory, gitworkspace, mkfile, package::PackageReader, report};
use log::{debug, error, info};
use std::io::Error;
use structopt::StructOpt;

#[derive(Debug, StructOpt)]
#[structopt(
    name = "brdiff",
    about = "compare two BR package set. The app uses output generated by the 'show-info' command from Buildroot"
)]
struct Options {
    #[structopt(
        short = "f",
        long = "first",
        default_value = "first.json",
        help = "path to the first JSON,mk(s)"
    )]
    path_first: String,

    #[structopt(
        short = "s",
        long = "second",
        default_value = "second.json",
        help = "path to the second JSON,mk(s)"
    )]
    path_second: String,

    #[structopt(
        short = "m",
        long = "mode",
        default_value = "fast",
        help = "type of a report [fast,full]"
    )]
    mode: String,

    #[structopt(
        short = "w",
        long = "workdir",
        default_value = "/tmp/brdiff",
        help = "path to the working directory"
    )]
    path_workdir: String,

    #[structopt(short = "k", long = "key", help = "SSH key", default_value = "")]
    key: String,

    #[structopt(
        short = "c",
        long = "clean",
        parse(try_from_str),
        default_value = "false",
        help = "clean working directory before run"
    )]
    clean: bool,

    #[structopt(
        long = "short-history",
        parse(try_from_str),
        default_value = "false",
        help = "short git history"
    )]
    short_history: bool,

    #[structopt(short = "o", long = "output", help = "output file to report")]
    output: Option<String>,
}

fn guess_reader(filename: &str) -> Result<Box<dyn PackageReader<Error = Error>>, Error> {
    if filename.ends_with(".json") {
        info!("use ShowInfo reader for {}", filename);
        Ok(Box::new(show_info::ReportReader::new(filename)))
    } else if filename.ends_with(".mk") {
        info!("use MkFile reader for {}", filename);
        Ok(Box::new(mkfile::MkFileReader::new(filename)))
    } else if std::fs::read_dir(filename).is_ok() {
        info!("use default dir. reader for {}", filename);
        Ok(Box::new(mkfile::MkFileDirReader::new(filename)))
    } else {
        info!("use default file reader for {}", filename);
        Ok(Box::new(show_info::ReportReader::new(filename)))
    }
}

fn run(opts: Options) -> Result<(), Error> {
    let first = guess_reader(&opts.path_first)?.read()?;
    let second = guess_reader(&opts.path_second)?.read()?;
    let mut diffs = diffs::build(&first, &second);
    if opts.mode == "full" {
        debug!("try to build full history for {} package(s)", diffs.len());
        let mut wsopts = gitworkspace::Options::new(&opts.path_workdir);
        wsopts.key = opts.key;
        wsopts.clean_workspace = opts.clean;
        wsopts.short_history = opts.short_history;
        githistory::append(&mut diffs, &wsopts)?;
    };
    report::print_diffs(&diffs);
    if let Some(file) = opts.output {
        report::write_diffs(&file, &diffs)?;
    }
    Ok(())
}

fn main() {
    env_logger::init();

    let opts = Options::from_args();
    match run(opts) {
        Ok(_) => {
            println!("Done")
        }
        Err(err) => {
            error!("diff fails:{:?}", err)
        }
    }
}
